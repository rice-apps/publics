import { CHANNEL_STATES } from './lib/constants';
import Push from './lib/push';
import RealtimeClient from './RealtimeClient';
import Timer from './lib/timer';
import RealtimePresence, { RealtimePresenceJoinPayload, RealtimePresenceLeavePayload, RealtimePresenceState, REALTIME_PRESENCE_LISTEN_EVENTS } from './RealtimePresence';
export declare type RealtimeChannelOptions = {
    config: {
        /**
         * self option enables client to receive message it broadcast
         * ack option instructs server to acknowlege that broadcast message was received
         */
        broadcast?: {
            self?: boolean;
            ack?: boolean;
        };
        /**
         * key option is used to track presence payload across clients
         */
        presence?: {
            key?: string;
        };
    };
};
export declare type RealtimePostgresChangesPayload<T extends {
    [key: string]: any;
}> = {
    schema: string;
    table: string;
    commit_timestamp: string;
    eventType: `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.INSERT}` | `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.UPDATE}` | `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.DELETE}`;
    new: T | {};
    old: Partial<T> | {};
    errors: string[];
};
export declare type RealtimeChannelSendResponse = 'ok' | 'timed out' | 'rate limited';
export declare enum REALTIME_POSTGRES_CHANGES_LISTEN_EVENT {
    ALL = "*",
    INSERT = "INSERT",
    UPDATE = "UPDATE",
    DELETE = "DELETE"
}
export declare enum REALTIME_LISTEN_TYPES {
    BROADCAST = "broadcast",
    PRESENCE = "presence",
    POSTGRES_CHANGES = "postgres_changes"
}
export declare enum REALTIME_SUBSCRIBE_STATES {
    SUBSCRIBED = "SUBSCRIBED",
    TIMED_OUT = "TIMED_OUT",
    CLOSED = "CLOSED",
    CHANNEL_ERROR = "CHANNEL_ERROR"
}
export default class RealtimeChannel {
    topic: string;
    params: RealtimeChannelOptions;
    socket: RealtimeClient;
    bindings: {
        [key: string]: {
            type: string;
            filter: {
                [key: string]: any;
            };
            callback: Function;
            id?: string;
        }[];
    };
    timeout: number;
    state: CHANNEL_STATES;
    joinedOnce: boolean;
    joinPush: Push;
    rejoinTimer: Timer;
    pushBuffer: Push[];
    presence: RealtimePresence;
    constructor(topic: string, params: RealtimeChannelOptions, socket: RealtimeClient);
    subscribe(callback?: (status: `${REALTIME_SUBSCRIBE_STATES}`, err?: Error) => void, timeout?: number): RealtimeChannel;
    presenceState(): RealtimePresenceState;
    track(payload: {
        [key: string]: any;
    }, opts?: {
        [key: string]: any;
    }): Promise<RealtimeChannelSendResponse>;
    untrack(opts?: {
        [key: string]: any;
    }): Promise<RealtimeChannelSendResponse>;
    on(type: `${REALTIME_LISTEN_TYPES.BROADCAST}`, filter: {
        event: string;
    }, callback: (payload: {
        type: `${REALTIME_LISTEN_TYPES.BROADCAST}`;
        event: string;
        [key: string]: any;
    }) => void): RealtimeChannel;
    on(type: `${REALTIME_LISTEN_TYPES.PRESENCE}`, filter: {
        event: `${REALTIME_PRESENCE_LISTEN_EVENTS}`;
    }, callback: (payload: RealtimePresenceJoinPayload | RealtimePresenceLeavePayload | undefined) => void): RealtimeChannel;
    on<T extends {
        [key: string]: any;
    }>(type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`, filter: {
        event: `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT}`;
        schema: string;
        table?: string;
        filter?: string;
    }, callback: (payload: RealtimePostgresChangesPayload<T>) => void): RealtimeChannel;
    send(payload: {
        type: string;
        [key: string]: any;
    }, opts?: {
        [key: string]: any;
    }): Promise<RealtimeChannelSendResponse>;
    updateJoinPayload(payload: {
        [key: string]: any;
    }): void;
    /**
     * Leaves the channel.
     *
     * Unsubscribes from server events, and instructs channel to terminate on server.
     * Triggers onClose() hooks.
     *
     * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:
     * channel.unsubscribe().receive("ok", () => alert("left!") )
     */
    unsubscribe(timeout?: number): Promise<'ok' | 'timed out' | 'error'>;
    _push(event: string, payload: {
        [key: string]: any;
    }, timeout?: number): Push;
    /**
     * Overridable message hook
     *
     * Receives all events for specialized message handling before dispatching to the channel callbacks.
     * Must return the payload, modified or unmodified.
     */
    _onMessage(_event: string, payload: any, _ref?: string): any;
    _isMember(topic: string): boolean;
    _joinRef(): string;
    _trigger(type: string, payload?: any, ref?: string): void;
    _isClosed(): boolean;
    _isJoined(): boolean;
    _isJoining(): boolean;
    _isLeaving(): boolean;
    _replyEventName(ref: string): string;
    _on(type: string, filter: {
        [key: string]: any;
    }, callback: Function): this;
    _off(type: string, filter: {
        [key: string]: any;
    }): this;
    private static isEqual;
    private _rejoinUntilConnected;
    /**
     * Registers a callback that will be executed when the channel closes.
     */
    private _onClose;
    /**
     * Registers a callback that will be executed when the channel encounteres an error.
     */
    private _onError;
    /**
     * Returns `true` if the socket is connected and the channel has been joined.
     */
    private _canPush;
    private _rejoin;
    private _getPayloadRecords;
}
//# sourceMappingURL=RealtimeChannel.d.ts.map